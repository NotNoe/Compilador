package constructorast;

import java_cup.runtime.*;
import alex.AnalizadorLexicoExp;
import alex.UnidadLexica;
import alex.TokenValue;
import errors.GestionErroresExp;
import ast.*;

scan with {: return getScanner().next_token(); :};
//action code {:
//   ... add some code to declare and initialize e.g. variables used by the code embedded in the grammar
//:};
parser code {: 
   private GestionErroresExp errores;
   public void syntax_error(Symbol unidadLexica) {
     errores.errorSintactico((UnidadLexica)unidadLexica);
   }
:};
init with {: 
   errores = new GestionErroresExp();
   AnalizadorLexicoExp alex = (AnalizadorLexicoExp)getScanner();
   alex.fijaGestionErrores(errores);
:};


terminal  INT, CHAR, BOOL, CLASS, STRUCT, FOR, WHILE, IF,
SWITCH, BREAK, CONTINUE, CONST, VOID, DEFAULT, CASE, NEW, RETURN,
TRUE, FALSE, THIS, DELETE, IDEN, ENT, SUMA, AST, RESTA, DIV,
AND, OR, PAP, PCIERRE, CAP, CCIERRE, LAP, LCIERRE, MAYORIG,
MAYOR, MENORIG, MENOR, IGUAL, DESIG, NEG, ASIG, REF, MOD,
PUNTO, PUNTOCOMA, COMA, CARACTER, TYPEDEF, ELSE;

non terminal P, ASIGNACION, FUNCION, PROCEDIMIENTO, CLASE, ESTRUCTURADO, DEFTIPO, DECLARACION, TIPO, BLOQUE_INSTRUCCIONES, INSTRUCCION, PARAMETROS, AUX1, CUERPO_CLASE,
IDENTIFICADOR, EXPRESION, I1, I2, I3, CONDICIONAL, MIENTRAS, PARA, SELECTOR, DEVOLVER, BORRADO, CASE_INDIVIDUAL, CUERPO_CASE,
E1, E2, E3, E4, E5, E6, E7, LISTA, SEQ_EXPRE, SEQ_EXPRE_NOVACIA, T1, T2, LLAMADA;

P ::= DECLARACION P | FUNCION P | PROCEDIMIENTO P | CLASE P | ESTRUCTURADO P | DEFTIPO P | ;


IDENTIFICADOR ::= AST IDENTIFICADOR |I1 ;
I1 ::= I1 PUNTO I2 | I2;
I2 ::= I2 CAP EXPRESION CCIERRE | I3;
I3 ::= IDEN | THIS | PAP IDENTIFICADOR PCIERRE ;

TIPO ::= AST TIPO | T1 ;
T1 ::= T1 CAP ENT CCIERRE | T2 ;
T2 ::= INT | CHAR | BOOL | PAP TIPO PCIERRE | IDEN;


DECLARACION ::= TIPO IDEN ASIG EXPRESION PUNTOCOMA | TIPO IDEN PUNTOCOMA | CONST TIPO IDEN ASIG EXPRESION PUNTOCOMA ;
ASIGNACION ::= IDENTIFICADOR ASIG EXPRESION PUNTOCOMA ;
ESTRUCTURADO ::= STRUCT LAP BLOQUE_INSTRUCCIONES LCIERRE IDEN PUNTOCOMA ;
BLOQUE_INSTRUCCIONES ::= INSTRUCCION BLOQUE_INSTRUCCIONES | ;
FUNCION ::= TIPO IDEN PAP PARAMETROS PCIERRE LAP BLOQUE_INSTRUCCIONES LCIERRE ;
AUX1 ::= TIPO IDEN COMA AUX1 | TIPO IDEN | TIPO REF IDEN | TIPO REF IDEN COMA AUX1 ;
PARAMETROS ::= AUX1 | ;
PROCEDIMIENTO ::= VOID IDEN PAP PARAMETROS PCIERRE LAP BLOQUE_INSTRUCCIONES LCIERRE ;
CUERPO_CLASE ::= DECLARACION CUERPO_CLASE | FUNCION CUERPO_CLASE | PROCEDIMIENTO CUERPO_CLASE | ;
CLASE ::= CLASS LAP CUERPO_CLASE LCIERRE IDEN PUNTOCOMA ;
DEFTIPO ::= TYPEDEF TIPO IDEN PUNTOCOMA ;


INSTRUCCION ::= DECLARACION | ASIGNACION | MIENTRAS | PARA | SELECTOR | DEVOLVER | BREAK PUNTOCOMA | CONTINUE PUNTOCOMA | BORRADO | EXPRESION PUNTOCOMA | CONDICIONAL;


CONDICIONAL ::= IF PAP EXPRESION PCIERRE LAP BLOQUE_INSTRUCCIONES LCIERRE | IF PAP EXPRESION PCIERRE LAP BLOQUE_INSTRUCCIONES LCIERRE ELSE LAP BLOQUE_INSTRUCCIONES LCIERRE;
MIENTRAS ::= WHILE PAP EXPRESION PCIERRE LAP BLOQUE_INSTRUCCIONES LCIERRE;
PARA ::= FOR PAP DECLARACION EXPRESION PUNTOCOMA BLOQUE_INSTRUCCIONES PCIERRE LAP BLOQUE_INSTRUCCIONES LCIERRE;
DEVOLVER ::= RETURN EXPRESION;
BORRADO ::= DELETE IDENTIFICADOR;
SELECTOR ::= SWITCH PAP EXPRESION PCIERRE LAP CUERPO_CASE LCIERRE;
CUERPO_CASE ::= CASE_INDIVIDUAL CUERPO_CASE | ;
CASE_INDIVIDUAL ::= CASE EXPRESION LAP BLOQUE_INSTRUCCIONES LCIERRE | DEFAULT LAP BLOQUE_INSTRUCCIONES LCIERRE;


EXPRESION ::= RESTA EXPRESION | NEG EXPRESION | REF EXPRESION | E1 ;
E1 ::= E1 DIV E2 | E1 MOD E2 | E1 AST E2 | E2 ;
E2 ::= E2 SUMA E3 | E2 RESTA E3 | E3 ;
E3 ::= E3 MENORIG E4 | E3 MENOR E4 | E3 MAYORIG E4 | E3 MAYOR E4 | E4 ;
E4 ::= E4 IGUAL E5 | E4 DESIG E5 | E5 ;
E5 ::= E5 AND E6 | E6 ;
E6 ::= E6 OR E7 | E7 ;
E7 ::= TRUE | FALSE | ENT | CARACTER | IDENTIFICADOR | LISTA | PAP IDENTIFICADOR PCIERRE | LLAMADA  | NEW TIPO PAP ENT PCIERRE;

LLAMADA ::= IDEN PAP SEQ_EXPRE PCIERRE ;

SEQ_EXPRE_NOVACIA ::= EXPRESION | EXPRESION COMA SEQ_EXPRE_NOVACIA;
SEQ_EXPRE ::= SEQ_EXPRE_NOVACIA | ;
LISTA ::= CAP SEQ_EXPRE CCIERRE ;












